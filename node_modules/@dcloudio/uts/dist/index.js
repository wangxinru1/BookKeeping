"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuild = exports.runDev = exports.bundle = exports.bundleSwift = exports.bundleKotlin = exports.parse = exports.UtsTargetExtNames = exports.UtsTarget = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const chokidar_1 = __importDefault(require("chokidar"));
const api_1 = require("./api");
const types_1 = require("./types");
const utils_1 = require("./utils");
var types_2 = require("./types");
Object.defineProperty(exports, "UtsTarget", { enumerable: true, get: function () { return types_2.UtsTarget; } });
const UtsTargetDirs = {
    [types_1.UtsTarget.KOTLIN]: 'app-android',
    [types_1.UtsTarget.SWIFT]: 'app-ios',
};
exports.UtsTargetExtNames = {
    [types_1.UtsTarget.KOTLIN]: 'kt',
    [types_1.UtsTarget.SWIFT]: 'swift',
};
function resolveDefaultOutputDir(mode, inputDir) {
    return path_1.default.resolve(inputDir, '../dist/' + mode);
}
function parseOptions(mode, target, opts) {
    const { input } = opts;
    if (!(input === null || input === void 0 ? void 0 : input.dir)) {
        throw new Error(`input.dir is required.`);
    }
    if (!fs_extra_1.default.existsSync(input.dir)) {
        throw new Error(`${input} is not found.`);
    }
    const inputSrcDir = resolveSrcDir(target, input.dir);
    if (!fs_extra_1.default.existsSync(inputSrcDir)) {
        throw new Error(`${inputSrcDir} is not found.`);
    }
    if (!opts.output) {
        opts.output = {
            dir: '',
            sourceMap: '',
            extname: exports.UtsTargetExtNames[target],
        };
    }
    if (!opts.output.dir) {
        opts.output.dir = resolveDefaultOutputDir(mode, input.dir);
    }
    if (!opts.output.extname) {
        opts.output.extname = exports.UtsTargetExtNames[target];
    }
    opts.silent = opts.silent === true;
    return opts;
}
const EXTNAME = '.uts';
function resolveSrcDir(target, dir) {
    return path_1.default.join(dir, UtsTargetDirs[target]);
}
function initInputOptions(_, root) {
    return {
        root,
        filename: '',
    };
}
function initOutputOptions(target, outDir, pkg, imports = [], sourceMap, inlineSourcesContent) {
    return {
        outDir,
        package: pkg,
        imports,
        sourceMap: sourceMap ? sourceMap : false,
        inlineSourcesContent,
        extname: exports.UtsTargetExtNames[target],
    };
}
function initOptions(target, { input: { dir: inputDir }, output: { dir: outputDir, package: pkg, imports, sourceMap, inlineSourcesContent, }, }) {
    const inputSrcDir = resolveSrcDir(target, inputDir);
    const outputSrcDir = resolveSrcDir(target, outputDir);
    const input = initInputOptions(target, inputSrcDir);
    const output = initOutputOptions(target, outputSrcDir, pkg || '', imports, sourceMap, !!inlineSourcesContent);
    return { input, output };
}
async function watch(target, toOptions) {
    fs_extra_1.default.emptyDirSync(toOptions.output.dir);
    const { input, output } = initOptions(target, toOptions);
    const inputDir = toOptions.input.dir;
    const outputDir = toOptions.output.dir;
    const inputSrcDir = input.root;
    const outputSrcDir = output.outDir;
    const extname = toOptions.input.extname || EXTNAME;
    const silent = !!toOptions.silent;
    // 先完整编译后，再启用监听
    doBuild(target, {
        watch: true,
        input,
        output,
        inputDir,
        outputDir,
        inputSrcDir,
        outputSrcDir,
        extname,
        silent,
    }).then(() => {
        // TODO 监听动态添加的资源文件
        chokidar_1.default
            .watch('**/*' + extname, {
            cwd: inputSrcDir,
            ignored: ['**/*.d' + extname],
            ignoreInitial: true,
        })
            .on('add', (filename) => {
            buildFile(target, path_1.default.resolve(inputSrcDir, filename), input, output).then((res) => {
                if (!silent) {
                    (0, utils_1.printUtsResult)(res);
                    (0, utils_1.printDone)(true);
                }
            });
        })
            .on('change', (filename) => {
            buildFile(target, path_1.default.resolve(inputSrcDir, filename), input, output).then((res) => {
                if (!silent) {
                    (0, utils_1.printUtsResult)(res);
                    (0, utils_1.printDone)(true);
                }
            });
        })
            .on('unlink', (filename) => {
            try {
                fs_extra_1.default.unlinkSync(path_1.default.resolve(outputSrcDir, filename));
            }
            catch (e) { }
        });
    });
}
function doBuild(target, { watch, silent, extname, inputSrcDir, input, output }) {
    const files = fast_glob_1.default.sync('**/*' + extname, {
        absolute: true,
        cwd: inputSrcDir,
        ignore: ['**/*.d' + extname],
    });
    return Promise.all(files.map((filename) => buildFile(target, filename, input, output).catch((error) => {
        return {
            error,
        };
    }))).then((res) => {
        !silent && (0, utils_1.printUtsResults)(res, watch);
        return res;
    });
}
function build(target, toOptions) {
    fs_extra_1.default.emptyDirSync(toOptions.output.dir);
    const { input, output } = initOptions(target, toOptions);
    const inputDir = toOptions.input.dir;
    const outputDir = toOptions.output.dir;
    const inputSrcDir = input.root;
    const outputSrcDir = output.outDir;
    const extname = toOptions.input.extname || EXTNAME;
    const silent = !!toOptions.silent;
    return doBuild(target, {
        watch: false,
        input,
        output,
        inputDir,
        outputDir,
        inputSrcDir,
        outputSrcDir,
        extname,
        silent,
    });
}
function buildFile(target, filename, input, output) {
    const toOptions = {
        input: {
            ...input,
            filename,
        },
        output: {
            ...output,
        },
    };
    const start = process.hrtime();
    return (target === types_1.UtsTarget.KOTLIN ? (0, api_1.toKotlin)(toOptions) : (0, api_1.toSwift)(toOptions)).then((res) => {
        res.time = (0, utils_1.timeEnd)(start);
        return res;
    });
}
var api_2 = require("./api");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return api_2.parse; } });
Object.defineProperty(exports, "bundleKotlin", { enumerable: true, get: function () { return api_2.bundleKotlin; } });
Object.defineProperty(exports, "bundleSwift", { enumerable: true, get: function () { return api_2.bundleSwift; } });
function bundle(target, opts) {
    if (target === types_1.UtsTarget.KOTLIN) {
        return (0, api_1.bundleKotlin)(opts);
    }
    else if (target === types_1.UtsTarget.SWIFT) {
        return (0, api_1.bundleSwift)(opts);
    }
    return Promise.resolve({});
}
exports.bundle = bundle;
function runDev(target, opts) {
    opts = parseOptions('dev', target, opts);
    !opts.silent && (0, utils_1.printStartup)(target, 'development');
    watch(target, opts);
}
exports.runDev = runDev;
function runBuild(target, opts) {
    opts = parseOptions('build', target, opts);
    !opts.silent && (0, utils_1.printStartup)(target, 'production');
    build(target, opts);
}
exports.runBuild = runBuild;
